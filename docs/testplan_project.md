# План сквозного тестирования API (MVP): Modules / Tasks / Submissions

## Введение

Данный документ описывает сценарии сквозного (end-to-end) тестирования MVP системы (API) для работы с **модулями**, **задачами** и **посылками решений (submissions)**. План составлен по существующим проверкам из Postman-коллекции и повторяет структуру примера testplan.md.

Тесты рассчитаны на запуск через Postman Runner (или ручное выполнение тех же HTTP-запросов).

**Охват MVP**:
- Получение списка задач и конкретной задачи
- Создание посылки решения к задаче и проверка её статуса
- Получение списка модулей, получение модуля по ID
- Пометка модуля как прочитанного
- Негативные проверки на несуществующий moduleId

**Общие предусловия для всех тестов**:
- Система развернута и доступна
- Известен базовый URL API и он задан в переменной окружения Postman `baseUrl` (например: `http://localhost:8080`)
- В системе есть хотя бы **1 модуль** и хотя бы **1 задача**
- Поддерживается заголовок `X-Idempotency-Key` для идемпотентных операций (используется в тестах)
- Для цепочек тестов Postman окружение позволяет сохранять переменные `taskId`, `moduleId`, `submissionId`, `idempotencyKey`

---

## 1. Тестирование задач (Tasks)

### Тест 1.1: Получение списка задач

**Цель**: проверить, что эндпоинт возвращает список задач корректного формата и укладывается в SLA по времени ответа.

**Шаги**:
1. Отправить HTTP-запрос:
   ```
   GET {{baseUrl}}/tasks
   ```

**Ожидаемый результат**:
- HTTP статус: `200 OK`
- Тело ответа — JSON-массив
- Каждый элемент массива содержит обязательные поля:
  - `id`
  - `moduleId`
  - `title`
  - `description`
  - `maxScore`
- Время ответа `< 500 мс`
- Дополнительно: сохранить `taskId` первой задачи (для следующих тестов)

---

### Тест 1.2: Получение задачи по ID

**Цель**: проверить получение задачи по идентификатору и соответствие схемы ответа.

**Предусловия**:
- Выполнен Тест 1.1
- В окружении задан `taskId`

**Шаги**:
1. Отправить HTTP-запрос:
   ```
   GET {{baseUrl}}/tasks/{{taskId}}
   ```

**Ожидаемый результат**:
- HTTP статус: `200 OK`
- Тело ответа — объект задачи
- Поле `id` совпадает с `{{taskId}}`
- Присутствуют поля:
  - `moduleId`
  - `title`
  - `description`
  - `maxScore`
- Время ответа `< 500 мс`

---

## 2. Тестирование посылок решений (Submissions)

### Тест 2.1: Создание посылки решения для задачи

**Цель**: проверить создание новой посылки к задаче и корректность формата ответа.

**Предусловия**:
- Известен `taskId`
- Сформирован новый UUID для `X-Idempotency-Key` (в Postman генерируется в pre-request скрипте)

**Шаги**:
1. Сгенерировать `idempotencyKey` (UUID).
2. Отправить HTTP-запрос:
   ```
   POST {{baseUrl}}/tasks/{{taskId}}/submissions
   Headers:
     Content-Type: application/json
     X-Idempotency-Key: {{idempotencyKey}}
   Body:
   {
     "code": "a, b = map(int, input().split()); print(a + b)",
     "language": "python"
   }
   ```

**Ожидаемый результат**:
- HTTP статус: `201 Created`
- Тело ответа содержит поля:
  - `id` (сохранить как `submissionId`)
  - `taskId` = `{{taskId}}`
  - `status` ∈ `QUEUED | RUNNING | PASSED | FAILED`
  - `language` = `"python"`
  - `createdAt` (валидная дата/время)
- Время ответа `< 500 мс`

---

### Тест 2.2: Получение посылки по ID и ожидание финального статуса

**Цель**: проверить получение посылки и корректное поведение статусов обработки (polling до финала).

**Предусловия**:
- Выполнен Тест 2.1
- В окружении задан `submissionId`

**Шаги**:
1. Отправить HTTP-запрос:
   ```
   GET {{baseUrl}}/submissions/{{submissionId}}
   ```
2. Если `status` = `QUEUED` или `RUNNING`, повторять запрос периодически до получения финального статуса.

**Ожидаемый результат**:
- HTTP статус: `200 OK`
- В ответе присутствуют поля:
  - `id` = `{{submissionId}}`
  - `taskId` = `{{taskId}}`
  - `status` ∈ `QUEUED | RUNNING | PASSED | FAILED`
  - `language`
  - `createdAt`
- Время ответа `< 500 мс`
- При финальном статусе (`PASSED`/`FAILED`):
  - присутствует `updatedAt`
  - `updatedAt` ≥ `createdAt`
  - если `status` = `PASSED`, присутствует `score` и это число

---

## 3. Тестирование модулей (Modules)

### Тест 3.1: Получение списка модулей

**Цель**: проверить, что API возвращает список модулей корректного формата и сохраняет moduleId для следующих шагов.

**Шаги**:
1. Отправить HTTP-запрос:
   ```
   GET {{baseUrl}}/modules
   ```

**Ожидаемый результат**:
- HTTP статус: `200 OK`
- Тело ответа — JSON-массив модулей
- Для каждого элемента присутствуют поля:
  - `id`
  - `title`
  - `description`
  - `order` (число)
  - `isRead` (boolean)
- Время ответа `< 500 мс`
- Сохранить `moduleId` первого модуля

---

### Тест 3.2: Получение модуля по ID

**Цель**: проверить корректность получения модуля по идентификатору, схему ответа и признак прочитанности.

**Предусловия**:
- Выполнен Тест 3.1
- В окружении задан `moduleId`

**Шаги**:
1. Отправить HTTP-запрос:
   ```
   GET {{baseUrl}}/modules/{{moduleId}}
   ```

**Ожидаемый результат**:
- HTTP статус: `200 OK`
- Тело ответа — объект модуля
- `id` = `{{moduleId}}`
- Поля:
  - `title`, `description`
  - `order` — число
  - `isRead` — boolean
- Отдельная проверка: `isRead = true`
- Время ответа `< 500 мс`

---

### Тест 3.3: Пометка модуля как прочитанного

**Цель**: проверить операцию отметки прочитанности и отсутствие тела ответа.

**Предусловия**:
- Известен `moduleId`
- Сформирован новый UUID для `X-Idempotency-Key`

**Шаги**:
1. Сгенерировать `idempotencyKey` (UUID).
2. Отправить HTTP-запрос:
   ```
   POST {{baseUrl}}/modules/{{moduleId}}
   Headers:
     X-Idempotency-Key: {{idempotencyKey}}
   ```
3. Сразу выполнить Тест 3.2 (GET /modules/{moduleId}) для подтверждения `isRead = true`.

**Ожидаемый результат**:
- HTTP статус: `204 No Content`
- Тело ответа пустое
- После этого GET /modules/{moduleId} возвращает `isRead = true`

---

## 4. Негативные сценарии и обработка ошибок

### Тест 4.1: GET несуществующего модуля

**Цель**: проверить корректную ошибку при запросе несуществующего модуля.

**Шаги**:
1. Отправить HTTP-запрос:
   ```
   GET {{baseUrl}}/modules/00000000-0000-0000-0000-000000000000
   ```

**Ожидаемый результат**:
- HTTP статус: `404 Not Found`
- Тело ошибки содержит поля:
  - `errorId`
  - `code`
  - `message`

---

### Тест 4.2: POST к несуществующему модулю

**Цель**: проверить корректную ошибку при попытке отметить несуществующий модуль прочитанным.

**Шаги**:
1. Сгенерировать `idempotencyKey` (UUID).
2. Отправить HTTP-запрос:
   ```
   POST {{baseUrl}}/modules/00000000-0000-0000-0000-000000000000
   Headers:
     X-Idempotency-Key: {{idempotencyKey}}
   ```

**Ожидаемый результат**:
- HTTP статус: `404 Not Found`
- Тело ошибки содержит поля:
  - `errorId`
  - `code`
  - `message`

---

## 5. Комплексный сквозной сценарий (рекомендуемый прогон)

### Тест 5.1: Типичный пользовательский сценарий «модуль → задачи → посылка → результат»

**Цель**: выполнить полный цикл, который покрывает ключевые интеграции между разделами API.

**Шаги**:
1. Получить список модулей: `GET /modules` (сохранить `moduleId`)
2. Отметить модуль прочитанным: `POST /modules/{moduleId}` → ожидать `204`
3. Проверить модуль: `GET /modules/{moduleId}` → ожидать `isRead=true`
4. Получить список задач: `GET /tasks` (сохранить `taskId`)
5. Получить задачу: `GET /tasks/{taskId}`
6. Создать посылку: `POST /tasks/{taskId}/submissions` (сохранить `submissionId`)
7. Запрашивать статус посылки: `GET /submissions/{submissionId}` до `PASSED`/`FAILED`
8. При `PASSED` убедиться, что есть `score`

**Ожидаемый результат**:
- Все шаги возвращают ожидаемые HTTP-статусы и данные схемы
- На каждом шаге соблюдается ограничение по времени ответа, где оно указано в тестах
- Нет неконсистентных данных (например, чужой `taskId`/`submissionId`)

